/**
 * Definition for a point.
 * function Point(x, y) {
 *     this.x = x;
 *     this.y = y;
 * }
 */
/**
 * @param {Point[]} points
 * @return {number}
 */
var maxPoints = function(points) {
    if(!Array.isArray(points) || points.length === 0) {
        return 0;
    }
//    console.log(points);
    if(points.length === 1) {
        return 1;
    }
    var ref0 = [];
    var ref1 = {};
    var ref2 = {};
    points.forEach(function(point) {
        ref0.push(point);
    });
    ref0.sort(function(a, b) {
        if(a.x !== b.x) {
            return a.x - b.x;
        } else {
            return a.y - b.y;
        }
    });
    console.log(ref0);
    var i = 1;
    while(i < ref0.length) {
        if(ref0[i].x === ref0[i - 1].x) {
            var sp = [Number('Infinity'), ref0[i].x];
            if(typeof ref2[sp] === 'undefined') {
                ref2[sp] = [ref0[i - 1]];
            }
            ref2[sp].push(ref0[i]);
            if(ref0[i].y === ref0[i - 1].y) {
                ref0.splice(i, 1);
                continue;
            }
        }
        i ++;
    }
    if(ref0.length === 1) {
        return points.length;
    }
//    console.log(ref0);
    for(i = 0; i < ref0.length - 1; i ++) {
        for(var j = i + 1; j < ref0.length; j ++) {
            var A = (ref0[j].y - ref0[i].y) / (ref0[j].x - ref0[i].x);
            if(!isFinite(A)) {
                continue;
            }
            var C = ref0[i].y - A * ref0[i].x;
            if(typeof ref1[A] === 'undefined') {
                ref1[A] = new Set();
            }
            ref1[A].add(C);
        }
    }
    console.log(ref1);
    for(var a in ref1) {
        var itr = ref1[a].values();
        var c = itr.next().value;
        while(typeof c !== 'undefined') {
            for(i = 0; i < points.length; i ++) {
                if(a * points[i].x + c === points[i].y) {
                    var key = [a, c];
                    if(typeof ref2[key] === 'undefined') {
                        ref2[key] = [];
                    }
                    ref2[key].push(points[i]);
                }
            }
            c = itr.next().value;
        }
    }
    console.log(ref2);
    var max = 0;
    for(var prop in ref2) {
        max = (ref2[prop].length > max) ? ref2[prop].length : max;
    }
    return max;
};
